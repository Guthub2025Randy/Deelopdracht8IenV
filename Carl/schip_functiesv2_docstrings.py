# -*- coding: utf-8 -*-
"""Schip_functiesV2_docstrings.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r3aA416Mp4r3lN7osXBw6tcMJKrp63Hb
"""

# -*- coding: utf-8 -*-
"""schip_functies_n.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/113A52ub1agy3nAValpof8xL2UkiPONII
"""

from bibliotheek import *

def funcPlotFill(x_plot, y_plot, x_naam, y_naam, titel_naam, functie_naam, kleur_functie):
    plt.figure(figsize=(30,20))
    plt.plot(x_plot, y_plot, label=f"{functie_naam}", color=f'{kleur_functie}')
    plt.fill_between(x_plot, y_plot, alpha=0.3, color=f'{kleur_functie}')
    plt.xlabel(f"{x_naam}")
    plt.ylabel(f"{y_naam}")
    plt.title(f"{titel_naam}")
    plt.legend()
    plt.grid(True)
    plt.show()
    plt.close()
    return None

def funcPlot(x_plot, y_plot, x_naam, y_naam, titel_naam, functie_naam, kleur_functie):
    plt.figure(figsize=(8,5))
    plt.plot(x_plot, y_plot, label=f"{functie_naam}", color=f'{kleur_functie}')
    plt.xlabel(f"{x_naam}")
    plt.ylabel(f"{y_naam}")
    plt.title(f"{titel_naam}")
    plt.legend()
    plt.grid(True)
    plt.show()
    plt.close()
    return None

def interpolerenLocatie(dictionary_ballasttank, vulling_tank, tanknummer):
    """
    Deze functie bepaalt van het water een ballasttank het zwaartepunt. Als input neemt hij de dictionary waarin de zwaartepunten
    van de tank bij gegeven vullingen staat, de werkelijke vulling, en het tanknummer. Door interpolatie worden het zwaartepunt
    bepaald en teruggegeven als array.
    Inputs:
    dictionary_ballasttank (dictionary): dictionary met data uit van de ballasttank
    vulling_tank (float): het volume van de vulling van de tank in m³
    tanknummer (int): het nummer van de tank
    Returns:
    np.array([lcg,tcg,vcg]): het zwaartepunt van de vulling van de tank (array)
    """
    vol_key = f"vol_{tanknummer}"
    lcg_key = f"lcg_{tanknummer}"
    tcg_key = f"tcg_{tanknummer}"
    vcg_key = f"vcg_{tanknummer}"
    TVolume = dictionary_ballasttank[vol_key]
    lcgT = dictionary_ballasttank[lcg_key]
    tcgT = dictionary_ballasttank[tcg_key]
    vcgT = dictionary_ballasttank[vcg_key]
    lcg_interpol = ip.interp1d(TVolume, lcgT, kind='cubic')
    tcg_interpol = ip.interp1d(TVolume, tcgT, kind='cubic')
    vcg_interpol = ip.interp1d(TVolume, vcgT, kind='cubic')
    lcg = lcg_interpol(vulling_tank)
    tcg = tcg_interpol(vulling_tank)
    vcg = vcg_interpol(vulling_tank)
    return np.array([lcg,tcg,vcg])

def calculateWeightKraan(Krachten, Posities, H, kraan_lcg, swl_max):
    """
    Deze functie heeft als doel aan twee lijsten, een met floats die krachten representeren, en aan een ander van arrays die
    elk een positie in het xyz vlak representeren, respectievelijk de zwaartekrachten en hun aangrijpingspunten toe te voegen.
    Ook het gewicht van de deklading (ZwaarteWindmolen) wordt toegevoegd. De aangevulde lijsten worden teruggegeven.
    Inputs:
    Krachten (list): lijst met de alle zwaartekrachten van de onderdelen van het schip (nog zonder de kraan)
    Posities: lijst met de alle zwaartepunten van de onderdelen van het schip (nog zonder de kraan)
    H (float): holte in m
    kraan_lcg (float): x-coördinaat van het zwaartepunt van de kraan
    swl_max (float): in N
    Returns:
    Krachten (list): lijst met de alle zwaartekrachten van de onderdelen van het schip (nu met de kraan)
    Posities (list): lijst met de alle zwaartepunten van de onderdelen van het schip (nu met de kraan)
    """
    zwaarte_kheis = -swl_max
    array_positie_kheis = np.array([kraan_lcg, 8+(32.5*np.cos(np.deg2rad(60))), (H+1+(32.5*np.sin(np.deg2rad(60))))])
    zwaarte_kboom = -swl_max*0.17
    array_positie_kboom = np.array([kraan_lcg, 8+(0.5*32.5*np.cos(np.deg2rad(60))), (H+1+(0.5*32.5*np.sin(np.deg2rad(60))))])
    zwaarte_khuis = -swl_max*0.34
    array_positie_khuis = np.array([kraan_lcg, 8, H+1])
    zwaarte_windmolen = -WEIGHT_TRANSITION_PIECES
    array_positie_windmolen = np.array([32, -2, H+10])
    Posities.append(array_positie_kheis)
    Krachten.append(zwaarte_kheis)
    Posities.append(array_positie_kboom)
    Krachten.append(zwaarte_kboom)
    Posities.append(array_positie_khuis)
    Krachten.append(zwaarte_khuis)
    Posities.append(array_positie_windmolen)
    Krachten.append(zwaarte_windmolen)
    return krachten, posities

def calculateOpdrijvendeKracht(gewicht_water, onderwater_volume):
    """
    deze functie berekent de opdrijvende kracht op basis van het onderwatervolume en de dichtheid van water.
    Inputs:
    gewicht_water (float): soortelijk gewicht van water in N/m³
    onderwater_volume (float): onderwatervolume schip in m³
    Returns:
    opdrijvende_kracht (float): in N
    """
    opdrijvende_kracht = gewicht_water * onderwater_volume
    return opdrijvende_kracht

def calcPositiesmetkrachtenlijst1(dictionary_bulkheads, locatie3, kracht3, H, cob, staalgewicht, plaatdikte, kraan_lcg, swl_max, dictionary_hull, plaatdikte2, opdrijvende_kracht):
    """
    Deze functie doet exact hetzelfde als de functie calcPositiesmekrachtenlijst2, behalve dat hier het gewicht en zwaartepunt van tank 1
    niet als arguments worden gevraagd. Deze functie genereert dus lijsten waarmee een resultant transversaal moment kan worden
    berekend dat gelijk gecorrigeerd moet worden door de vulling van tank 1.
    Inputs:
    dictionary_bulkheads (dictionary): dictionary met gegevens van de tankschotten, afkomstig uit het bhdata bestand
    locatie3 (np.array): locatie van het zwaartepunt van tank 3 (x, y en z-coördinaten).
    kracht3 (float): gewicht van de vulling van tank 3 in N
    H (float): holte in m
    cob (np.array): drukkingspunt (x,y en z-coördinaten)
    staalgewicht (float): dichtheid van staal in kg/m³
    plaatdikte (float): plaatdikte van de schotten en spiegel in m
    kraan_lcg (float): lcg van de kraan
    swl_max (float): in N
    dictionary_hull (dictionary): dictionary met de gegevens van de romp uit het HullAreaData bestand
    plaatdikte2 (float): plaatdikte van de huid, dek en bodem in m
    opdrijvende_kracht (float): in N
    Returns:
    krachten1 (list): lijst met alle krachten in N
    posties1 (list): lijst met de aangrijppunten van alle krachten
    """
    posities = []
    krachten = []
    posities1 = []
    krachten1 = []
    for key, value in dictionary_bulkheads.items():
        posities.append(value[1:4])
        krachten.append(float(-value[0]*Staalgewicht*plaatdikte))
    for key, value in dictionary_hull.items():
        x = float(value[1])
        y = float(value[2])
        z = float(value[3])
        posities.append(np.array([x, y, z]))
        if key == "Transom Area ":
            krachten.append(float(-value[0]*Staalgewicht*plaatdikte))
        else:
            krachten.append(float(-value[0]*Staalgewicht*plaatdikte2))
    krachten1, posities1 = calculateWeightKraan(krachten, posities, H, kraan_lcg, swl_max)
    krachten1.append(float(-kracht3))
    krachten1.append(opdrijvende_kracht)
    posities1.append(locatie3)
    posities1.append(cob)
    return krachten1, posities1

def calculateMoment(positie,kracht):
    """
    deze functie berekent het kruisproduct tussen twee vectoren (in de vorm van arrays) en geeft een array terug die gelijk is
    aan dit kruisproduct. Als een krachtvector en positievector als arguments worden opgegeven berekent de functie dus het moment.
    Inputs:
    postie (np.array): positievector
    kracht (np.array): krachtvector
    Returns:
    Moment (np.array): kruisproduct/moment
    """
    Moment = np.cross(positie, kracht)
    return Moment

def calculateMomentensom(posities, krachten):
    """
    Deze functie ontvangt twee lijsten aan input. De lijst van posities hoort te bestaan uit arrays met drie elementen: de lcg,
    tcg en vcg van elke massa (in het geval van de opdrijvende kracht het cob). De lijst van krachten bestaat uit floats die gelijk
    zijn aan de grootte van de corresponderende (zwaarte)krachten. Door middel van een for loop en de eerder geschreven momentfunctie
    worden de momenten van alle krachten bij elkaar opgeteld. Vervolgens wordt dit in de vorm van een array die de resultante
    momentvector bevat teruggegeven (dus drie elementen overeenkomend met resp. moment rond de x-as, y-as en z-as.
    Inputs:
    posties (list): positievector
    krachten (list): krachtvector
    Returns:
    momentensom (np.array): het resulterende moment ontbonden in componenten rond de x-as, y-as en z-as.
    """
    if len(posities) != len(krachten):
        print("Error, niet gelijke hoeveelheden krachten gekregen voor de eerste momentensom")
        return None
    momentensom = np.array([0.0,0.0,0.0])
    for i in range(len(krachten)):
        positie_1 = posities[i][0]
        positie_2 = posities[i][1]
        positie_3 = posities[i][2]
        momentensom += calculateMoment(np.array([positie_1,positie_2,positie_3]), np.array([0, 0, krachten[i]]))
    return momentensom

def calculateVullingT1(arr_volume, arr_tcg, moment_som, arr_vulling_pc, water_gewicht):
  """
  Deze functie berekent het volume van tank 1 aan de hand van het transversale moment door een volume te
  kiezen dat dit moment compenseert. Eerst wordt er op basis van de arrays met de waarden voor het
  volume en het tcg op de bekende vullingsgraden een array met de momenten op die vullingsgraden opgesteld.
  Vervolgens wordt deze array geïnterpoleerd en uitgezet tegenover het volume. Ten slotte wordt de volumewaarde
  die correspondeert met het opgegeven transversale moment (moment_som[0]) bepaald en teruggegeven.
  Inputs:
  arr_volume (np.array): de array met tankvolumes uit het tankbestand uit grasshopper in m³
  arr_tcg (np.array): de array met tcg's van de tankvulling bij de vullingen van arr_volume
  moment_som (np.array): het te corrigeren moment in Nm
  arr_vulling_pc (np.array): de array met vullingspercentages die overeenkomen met de vullingen van arr_volume
  water_gewicht (float): dichtheid water in N/m³
  Returns:
  volume_acc(float): volume van het water in tank1 om transversaal krachtevenwicht te krijgen in m³
  """
  arr_moment = arr_volume*arr_tcg*watergewicht
  f = ip.interp1d(arr_moment,arr_volume, kind="cubic")
  volume_acc = f(moment_som[0])
  #grafiek
  f2 = ip.interp1d(arr_vulling_pc, arr_volume, kind="cubic")
  xnew = np.linspace(arr_vulling_pc[0], arr_vulling_pc[-1], 10000)
  ynew = f2(xnew)
  return volume_acc

def calcPositiesmetkrachtenlijst2(dic_bulk, positie_w_t1, kracht_w_t1, positie_w_t3, kracht_w_t3, h, cob, staalgewicht, plaatdikte_bh, kraan_lcg, swl_max, dic_hull, plaatdikte_romp,  opwaartse_kracht):
  """
  Het doel van deze functie is twee lijsten te creëeren: een met alle krachten en een met de corresponderende posities. Alleen
  het gewicht van tank 2 wordt nog niet gevraagd als argument, zodat dat met deze lijsten kan worden berekend.
  De krachten lijst bestaat uit floats terwijl de positielijst uit lijsten bestaat. Deze lijsten bevatten steeds drie elementen,
  respectievelijk de lcg, tcg en vcg van de massa (of het cob in het geval van de opdrijvende kracht). Hiervoor wordt er geïtereerd
  over de dictionaries waar de gegevens van de romp en schotten instaan, om daar de oppervlakten en zwaartepunten uit te halen. De
  oppervlakten worden met het staalgewicht en de dikte vermenigvuldigd om de massa te krijgen. Vervolgens worden de zwaartekrachten
  van de vullingen van tank 1 en tank 3 toegevoegd en de opdrijvende kracht, alsook hun zwaartepunten. Tot slot worden de gegevens
  kraan toegevoegd door middel van de kraanfunctie, die de zwaartekracht en zwaartepunt van de kraan bepaalt.
  Deze functie doet exact hetzelfde als de functie calcPositiesmekrachtenlijst2, behalve dat hier het gewicht en zwaartepunt van tank 1
  niet als arguments worden gevraagd. Deze functie genereert dus lijsten waarmee een resultant transversaal moment kan worden
  berekend dat gelijk gecorrigeerd moet worden door de vulling van tank 1.
  Inputs:
  dic_bulkheads (dictionary): dictionary met gegevens van de tankschotten, afkomstig uit het bhdata bestand
  positie_w_t1 (np.array): locatie van het zwaartepunt van de vulling van tank 1
  kracht_w_t3 (float): gewicht van de vulling van tank 3 in N
  positie_w_t3 (np.array): locatie van het zwaartepunt van de vulling van tank 3 (x, y en z-coördinaten).
  kracht3 (float): gewicht van de vulling van tank 3 in N
  h (float): holte in m
  cob (np.array): drukkingspunt (x,y en z-coördinaten)
  staalgewicht (float): dichtheid van staal in kg/m³
  plaatdikte (float): plaatdikte van de schotten en spiegel in m
  kraan_lcg (float): lcg van de kraan
  swl_max (float): in N
  dictionary_hull (dictionary): dictionary met de gegevens van de romp uit het HullAreaData bestand
  plaatdikte2 (float): plaatdikte van de huid, dek en bodem in m
  opdrijvende kracht (float): in N
  Returns:
  krachten1 (list): lijst met alle krachten
  posties1 (list): lijst met alle aangrijppunten van de krachten
  """
  krachten = []
  positie = []
  for x in dic_bulk:
    krachten.append(-dic_bulk[x][0]*staalgewicht*plaatdikte_bh)
    positie.append(dic_bulk[x][1:])
  for x in dic_hull:
    if x == "Transom Area ":
      krachten.append(-dic_hull[x][0]*staalgewicht*plaatdikte_bh)
      positie.append(dic_hull[x][1:])
    else:
      krachten.append(-dic_hull[x][0]*staalgewicht*plaatdikte_romp)
      positie.append(dic_hull[x][1:])
  krachten.append(-kracht_w_t3)
  krachten.append(opwaartse_kracht)
  krachten.append(-kracht_w_t1)
  positie.append(positie_w_t3)
  positie.append(cob)
  positie.append(positie_w_t1)
  krachten2, posities2 = calculateWeightKraan(krachten, positie, h, kraan_lcg, swl_max)
  return krachten2, posities2

def calculateKrachtensom1(krachten):
    """
    deze functie maakt van een lijst met krachten een float die gelijk is aan de som van al die krachten en geeft deze terug
    Inputs:
    krachten (np.array): lijst met krachtvectoren in N
    Returns:
    krachtensom (float): som van de krachten in N
    """
    krachtensom = 0
    for i in range(len(krachten)):
        krachtensom += np.sum(np.array([0,0, krachten[i]]), axis=0, keepdims=True)
    return krachtensom

def calculateVullingT2(krachtensom, watergewicht):
    """
    Deze functie genereert uit de resultante kracht het volume van het water in tank twee en geeft deze terug. Beide deze
    variabelen zijn floats.
    Inputs:
    krachtensom (float): resultante kracht in N
    watergewicht (float): dichtheid water in N/m³
    Returns:
    volume_t2 (float): volume van het ballastwater in tank 2
    """
    volume_t2 = krachtensom / watergewicht
    return volume_t2

def calculateKrachtsom2(krachtsom1, dic, plaatdikte, staalgewicht):
  """
  Deze functie neemt de eerste krachtsom en voegt hier het gewicht van de bulkheads van tank 2 aan toe.
  Inputs:
  krachtensom1 (float): som van alle krachten behalve die van de schotten van tank 2 in N
  dic (dictionary): dictionary met gegevens van de tankschotten uit het bestand BHData
  plaatdikte (float): plaatdikte van de schotten in m
  staalgewicht (float): dichtheid van staal in N/m³
  """
  oppervlakte_bh_tank2 = 0
  for x in dic:
    oppervlakte_bh_tank2 += dic[x][0]
  tweedekrachtsom = krachtsom1 + (oppervlakte_bh_tank2*plaatdikte*staalgewicht)
  return tweedekrachtsom

def calcLcgtank2(momentensom2,krachtensom2):
    """
    deze functie haalt uit het het resultante moment rond de y-as en de resultante kracht de arm van tank 2. De resultante kracht
    in dit geval is het totale gewicht van tank 2 (dus water+tankschotten), berekend door alle andere gewichten bij elkaar op te
    tellen en daar de opdrijvende kracht van af te trekken.
    Inputs:
    momentensom2 (np.array): momentensom in Nm, als vector.
    krachtensom2 (float): som van de opdrijvende kracht en alle zwaartekrachten behalve die van tank 2 (dwarsschotten en ballastwater) in N
    Returns:
    lcgt2 (float): lcg van tank 2
    """
    lcgt2 = momentensom2[1]/-krachtensom2
    return lcgt2

def calculateIttanks(dictionary_traagheidsmoment1, dictionary_traagheidsmoment2, dictionary_traagheidsmoment3, dictionary_vulling1, dictionary_vulling2, dictionary_vulling3, tankvulling1, tankvulling2, tankvulling3):
    """
    Deze functie neemt als arguments arrays met de traagheidsmomenten op verschillende volumes en arrays met de correspoderende
    volumes van elke aan. Ook neemt hij de werkelijke volumes per tank aan. Vervolgens wordt met interpolatie het werkelijke
    traagheidsmoment van het wateroppervlak per tank bepaald. Deze worden bij elkaar opgeteld en teruggegeven als float.
    (de lokale variabelen heten "dictionary" omdat de arrays in dictionaries staan, maar de daadwerkelijk gevraagde inputs zijn
    arrays)
    Inputs:
    dictionary_traagheidsmoment1 (dictionary): dictionary met de gegevens van de traagheidsmomenten van het wateroppervlak van ballasttank 1
    dictionary_traagheidsmoment2 (dictionary): dictionary met de gegevens van de traagheidsmomenten van het wateroppervlak van ballasttank 2
    dictionary_traagheidsmoment3 (dictionary): dictionary met de gegevens van de traagheidsmomenten van het wateroppervlak van ballasttank 3
    dictionary_vulling1 (dictionary): dictionary met de gegevens van de vulling van ballasttank 1
    dictionary_vulling2 (dictionary): dictionary met de gegevens van de vulling van ballasttank 2
    dictionary_vulling3 (dictionary): dictionary met de gegevens van de vulling van ballasttank 3
    tankvulling1 (float): daadwerkelijke vulling van tank 1 in m³
    tankvulling2 (float): daadwerkelijke vulling van tank 2 in m³
    tankvulling3 (float): daadwerkelijke vulling van tank 3 in m³
    Returns:
    s_it (float): som van de dwarsscheepse traagheidsmomenten van de oppervlaktes van de waterlijnen van de tanks in m⁴

    """
    traagheidsmoment_t1_dmv_tankfillingper = ip.interp1d(dictionary_vulling1, dictionary_traagheidsmoment1, kind='cubic')
    traagheidsmoment_t2_dmv_tankfillingper = ip.interp1d(dictionary_vulling2, dictionary_traagheidsmoment2, kind='cubic')
    traagheidsmoment_t3_dmv_tankfillingper = ip.interp1d(dictionary_vulling3, dictionary_traagheidsmoment3, kind='cubic')
    traagheidsmoment_1x = traagheidsmoment_t1_dmv_tankfillingper(tankvulling1)
    traagheidsmoment_2x = traagheidsmoment_t2_dmv_tankfillingper(tankvulling2)
    traagheidsmoment_3x = traagheidsmoment_t3_dmv_tankfillingper(tankvulling3)
    s_it = traagheidsmoment_1x + traagheidsmoment_2x + traagheidsmoment_3x
    return s_it

def removeBuoyantForce(lijst_positie, lijst_krachten, center_buoyancy, kracht_opdrijvend):
  """
  Deze functie haalt de cob en de opdrijvende kracht uit de lijsten met alle massa's en alle posities,
  zodat hiermee de totale zwaartepunten kunnen worden bepaald.
  lijst_positie (list): lijst met aangrijpingspunten van alle krachten
  lijst_krachten (list): lijst met grootten van alle krachten in N
  center_buoyancy (np.array): drukkingspunt
  kracht_opdrijvend (float): opdrijvende kracht in N
  Returns:
  lijst_positie (list): lijst met zwaartepunten van alle onderdelen van het schip
  lijst_krachten (list): lijst met zwaartekrachten van elk onderdeel van het schip
  """
  lijst_positie = [arr for arr in lijst_positie if not np.array_equal(arr, center_buoyancy)]
  for element in lijst_krachten:
    if element == kracht_opdrijvend:
      lijst_krachten.remove(element)
      break
  return lijst_positie, lijst_krachten

def calculateZwaartepuntschip(posities, krachten):
    """
    Deze functie berekent het totale zwaartepunt van het schip op basis van lijsten met de zwaartekrachten en zwaartepunten van
    elk onderdeel van het schip. De individuele zwaartekrachten en producten van zwaartekrachten met hun locatie worden in een for-
    loop bij elkaar opgeteld. Vervolgens wordt elk van de  gedeeld door de totale zwaartekracht gedeeld om het lcg, tcg, en
    vcg te bepalen. Als output geeft de functie een tuple van drie floats.
    Inputs:
    posities (list): lijst met het zwaartepunt van elk onderdeel van het schip
    krachten (list): lijst met de zwaartekracht van elk onderdeel van het schip
    Returns:
    lcg (float): lcg van het schip
    tcg (float): tcg van het schip
    vcg (float): vcg van het schip
    """
    krachtenopgeteld = 0
    lcg_krachten_en_posities_vermenigvuldigd = 0
    tcg_krachten_en_posities_vermenigvuldigd = 0
    vcg_krachten_en_posities_vermenigvuldigd = 0
    for i in range(len(krachten)):
        if len(krachten) != len(posities):
            print("Error, ongelijke hoeveelheden krachten en posities")
            return None
        else:
            x = posities[i][0]
            y = posities[i][1]
            z = posities[i][2]
            krachtenopgeteld += krachten[i]
            lcg_krachten_en_posities_vermenigvuldigd += x*krachten[i]
            tcg_krachten_en_posities_vermenigvuldigd += y*krachten[i]
            vcg_krachten_en_posities_vermenigvuldigd += z*krachten[i]
    lcg = lcg_krachten_en_posities_vermenigvuldigd/krachtenopgeteld
    tcg = tcg_krachten_en_posities_vermenigvuldigd/krachtenopgeteld
    vcg = vcg_krachten_en_posities_vermenigvuldigd/krachtenopgeteld
    return lcg, tcg, vcg

def calculateG_M(onderwatervolume, SIt, KG, KB, It):
    """
    Deze functie bepaalt het G'M op basis van de inputs onderwatervolume, de som van de traagheidsmomenten van de wateroppervlakten
    van de ballastanks, KG, KB en het traagheidsmoment van de waterlijn. Eerst wordt de GM bepaald, vervolgens wordt de
    vrijevloeistofcorrectie toegepast. Bij de vrijevloeistofcorrectie is ervan uitgegaan dat de dichtheid van de water in de
    ballasttanks gelijk zijn aan het water verplaatst door de romp. Alle inputs horen floats te zijn, net als return g'm.
    Imputs:
    onderwatervolume (float): in m³
    SIt (float): som van de dwarsscheepse traagheidsmomenten van de wateroppervlakten van de ballasttanks in m⁴
    KG (float): in m
    KB (float): in m
    It (float): dwarsscheeps traagheidsmoment van de waterlijn in m⁴
    Returns:
    g_m: G'M, voor vrije vloeistofoppervlakten gecorrigeerde GM.
    """
    gm = KB - KG + It/onderwatervolume
    gnulg = SIt/onderwatervolume
    g_m = gm - gnulg
    return g_m

# Begin deelopdracht 8

def opwaartseKracht(dictio_CSA, lengte_schip):
  """
  Functie berekent het verloop van de opdrijvende kracht over de lengte van het schip
  Inputs:
  dictio_CSA: dictionary met de oppervlakten van de dwarsdoorsneden van spanten van het onderwaterschip.
  lente_schip (np.array): array met de lengtewaardes van het schip per centimeter
  Returns:
  opwaartse_kracht_cm (np.array): array met de verdeelde opdrijvende kracht in N/m op elke centimeter van de lengte van het schip.
  """
    oppervlakte = dictio_CSA[" crossarea_in_m2"]
    lps = dictio_CSA["x_in_m"]
    oppervlakteInterp = ip.interp1d(lps, oppervlakte, kind='quadratic', fill_value='extrapolate')
    oppervlakte_cm = oppervlakteInterp(lengte_schip)
    onderwater_volume = []
    for i in range(len(oppervlakte_cm)-1):
        dx = lengte_schip[i+1]-lengte_schip[i]
        onderwater_volume.append(oppervlakte_cm[i]*dx)
    onderwater_volume.append(0)
    opwaartse_kracht_cm = np.array(onderwater_volume)*WEIGHT_WATER
    #funcPlotFill(lengte_schip, -opwaartse_kracht_cm, "Lengte van het schip (L) [m]", "Opwaartse kracht (p) in [N]", "De opwaartse kracht (p) in [N] over de lengte van het schip (L) [m]", "Opwaartse kracht (p) in [N]", 'b')
    return opwaartse_kracht_cm

def traagheidsmomentOverLengte(traagheidsmoment_csa_shell, Lengte_schip_csa_shell, lengte_schip):
  """
  Functie bepaalt het traagheidsmoment rond de y-as op elke centimeter lengte van het schip
  Inputs:
  traagheidsmoment_csa_shell (np.array): de traagheidsmomenten van de doorsnedes van de romp op bepaalde x-waarden
  Lengte_schip_csa_shell (np.array): de x-waarden die overeenkomen met de waarden van de traagheidsmomenten
  lengte_schip (np.array): array met de lengtewaardes van het schip per centimeter
  Returns:
  traagheidsmoment_csa_shell_cm (np.array): het traagheidsmoment rond de y-as op elke centimeter lengte van het schip
  """
  interpoleer_naar_cm = ip.interp1d(Lengte_schip_csa_shell, traagheidsmoment_csa_shell, kind='cubic')
  traagheidsmoment_csa_shell_cm = interpoleer_naar_cm(lengte_schip)
  return traagheidsmoment_csa_shell_cm

def ballastLoop(x_in_m, opp, lengte_schip):
  """
  Functie bepaalt de verdeelde belasting van de vulling van een tank op elke centimeter lengte van het schip
  Inputs:
  opp (np.array): oppervlakte van de dwarsdoorsnede van de het vullingswater in de tank op een aantal x-waarden
  x_in_m (np.array): de overeenkomende x-waarden
  lengte_schip (np.array): array met de lengtewaardes van het schip per centimeter
  Returns:
  neerwaartse_kracht (np.array): array met de verdeelde belasting van het water in de tank in N/m op elke centimeter van het schip
  """
  leng_scale = int(((x_in_m[-1] - x_in_m[0])*(len(lengte_schip)/(lengte_schip[-1] - lengte_schip[0]))))
  donnot = np.array([0.0])
  rescaling_length = np.linspace(x_in_m[0], x_in_m[-1], leng_scale)
  oppervlakte_interp = ip.interp1d(x_in_m, opp, kind='quadratic', fill_value=donnot)
  oppervlakte_cm = oppervlakte_interp(rescaling_length)
  water_volume = []
  for i in range(len(oppervlakte_cm)-1):
      dx = rescaling_length[i+1] - rescaling_length[i]
      water_volume.append(oppervlakte_cm[i]*dx)
  water_volume.append(0)
  neerwaartse_kracht_pre = np.array(water_volume)*WEIGHT_WATER
  neerwaartse_kracht = np.interp(lengte_schip, rescaling_length, neerwaartse_kracht_pre, left=0, right=0)
  return neerwaartse_kracht

def ballastwaterKracht(dic_tank, dic_tank_2, dic_tank_3, lengte_schip, scaling):
    """
    Functie bepaalt verdeelde belasting van drie tanks.
    Inputs:
    dic_tank: dictionary met gegevens van tank 1
    dic_tank_2: dictionary met gegevens van tank 2
    dic_tank_3: dictionary met gegevens van tank 3
    lengte_schip: array met de lengtewaardes van het schip per centimeter (np.array)
    scaling: ???
    Returns:
    neerwaartse_kracht: array met de verdeelde belasting van het water in de tank in N/m op elke centimeter van het schip (np.array)
    """
    oppervlakte1 = dic_tank[" crossarea_in_m2"]
    lps1 = dic_tank["x_in_m"]
    #leng_1 = int(((lps1[-1] - lps1[0])*(len(lengte_schip)/(lengte_schip[-1] - lengte_schip[0]))))
    #rescaling_length1 = np.linspace(lps1[0], lps1[-1], leng_1)
    #oppervlakteInterp1 = ip.interp1d(lps1, oppervlakte1, kind='cubic', fill_value=donnot)
    #oppervlakte1_cm = oppervlakteInterp1(rescaling_length1)
    #Water_volume1 = []
    oppervlakte2 = dic_tank_2[" crossarea_in_m2"]
    lps2 = dic_tank_2["x_in_m"]
    #leng_2 = int(((lps2[-1] - lps2[0])*(len(lengte_schip)/(lengte_schip[-1] - lengte_schip[0]))))
    #rescaling_length2 = np.linspace(lps2[0], lps2[-1], leng_2)
    #oppervlakteInterp2 = ip.interp1d(lps2, oppervlakte2, kind='cubic', fill_value=donnot)
    #oppervlakte2_cm = oppervlakteInterp2(rescaling_length2)
    #Water_volume2 = []
    oppervlakte3 = dic_tank_3[" crossarea_in_m2"]
    lps3 = dic_tank_3["x_in_m"]
    neerwaartse_kracht1 = ballastLoop(lps1, oppervlakte1, lengte_schip)
    neerwaartse_kracht2 = ballastLoop(lps2, oppervlakte2, lengte_schip)
    neerwaartse_kracht3 = ballastLoop(lps3, oppervlakte3, lengte_schip)
    neerwaartse_kracht_cm = (neerwaartse_kracht1 + neerwaartse_kracht2 + neerwaartse_kracht3) * scaling
    #funcPlotFill(lengte_schip, neerwaartse_kracht_cm, "Lengte van het schip (L) [m]", "Neerwaartse kracht (Ballast) [N]", "De verdeelde belasting van het ballastwater over de lengte van het schip", "Ballast belasting [N]", 'r')
    return -neerwaartse_kracht_cm

def dwarskracht(q_x, lengte_schip):
    """
    Functie bepaalt de dwarskrachtlijn op basis van q(x) m.b.v. numerieke integratie
    Inputs:
    q_x (np.array): netto verdeelde belasting op elke centimeter lengte van het schip
    lengte_schip (np.array): array met de lengtewaardes van het schip per centimeter
    Returns:
    dwarskracht (np.array): dwarskracht op elke cm van lengte van het schip
    """
    dwarskracht = cumtrapz(q_x, lengte_schip, initial=0)
    dwarskracht[0]= 0
    dwarskracht[-1]= 0
    #funcPlotFill(lengte_schip, dwarskracht, "Lengte van het schip L [m]", "Dwarskracht V(x) [N]", "De dwarskracht V(x) [N] over de lengte van het schip L [m]", "Dwarskracht V(x)", 'orange')
    return dwarskracht

def buigendMoment(F_x, lengte_schip):
    """
    Functie bepaalt de momentenlijn op basis van de dwarskrachtlijn m.b.v. numerieke integratie
    Inputs:
    F_x (np.array): dwarskrachtlijn op elke centimeter lengte van het schip
    lengte_schip (np.array): array met de lengtewaardes van het schip per centimeter
    Returns:
    buigend_moment (np.array): buigend moment op elke cm van lengte van het schip
    """
    buigend_moment = cumtrapz(F_x, lengte_schip, initial=0)
    buigend_moment[0]= 0
    buigend_moment[-1]= 0
    #funcPlotFill(lengte_schip, buigend_moment, "Lengte van het schip L [m]", "Buigend moment M(x) [Nm]", "Het buigend moment M(x) [Nm] over de lengte van het schip L [m]", "Buigend moment M(x)", 'yellow')
    return buigend_moment

def reducMoment(buigend_moment, traagheidsmoment):
    """
    Functie bepaalt het gereduceerd moment op elke centimeter lengte van het schip
    Inputs:
    buigend_moment (np.array): buigend moment op elke centimeter lengte van het schip
    traagheidsmoment (np.array): traagheidsmoment van de doorsnede van het schip rond de y-as op elke centimeter lengte van het schip
    Returns:
    gereduceerd_moment (np.array): gereduceerd moment
    """
    gereduceerd_moment = buigend_moment/(ELASTICITEISMODULUS*traagheidsmoment)
    return gereduceerd_moment


# door het gereduceerde moment de integreren krijg je de verdraaiing accent (phi accent)
def hoekverdraaiingAcc(gereduceerd_moment_uitkomst, lengte_schip):
    """
    Functie bepaalt de hoekverdraaiing phi'
    Inputs:
    gereduceerd_moment_uitkomst (np.array): gereduceerd moment op elke centimeter lengte van het schip
    lengte schip (np.array): array met de lengtewaardes van het schip per centimeter
    Returns:
    phi_accent (np.array): phi' op elke centimeter lengte van het schip
    """
    phi_accent = cumtrapz(lengte_schip, gereduceerd_moment_uitkomst, initial=0)
    phi_accent[0]=0
    #funcPlotFill(lengte_schip, phi_accent, "Lengte van het schip L [m]", "φ(x)' [deg]", "De hoekverdraaiing in graden φ(x)' [deg] over de lengte van het schip L [m]", "De hoekverdraaiing φ(x)' [deg]", 'green')
    return phi_accent


# door de verdraaing accent (phi accent) te integreren krijg je de doorbuiging accent (w')

def doorbuigingAcc(phi_accent, lengte_schip):
    """
    Functie bepaalt de doorbuiging w'
    Inputs:
    phi_accent (np.array): phi' op elke centimeter lengte van het schip
    lengte schip (np.array): array met de lengtewaardes van het schip per centimeter
    Returns:
    w_acc (np.array): w' op elke centimeter lengte van het schip
    """
    w_acc = cumtrapz(lengte_schip, phi_accent, initial =0 )
    w_acc[0]=0
    #funcPlotFill(lengte_schip, w_acc, "Lengte van het schip L [m]", "Doorbuiging w'(x) [m]", "Doorbuiging w'(x) [m] over de lengte van het schip L [m]", "Doorbuiging w'(x) [m]", 'brown')
    return w_acc

#phi
def hoekverdraaiing(phi_acc, lengte_schip, c):
    """
    Functie bepaalt de hookverdraaiing phi
    Inputs:
    phi_acc (np.array): phi' op elke centimeter lengte van het schip
    lengte_schip (np.array): array met de lengtewaardes van het schip per centimeter
    c (float): integratieconstante
    Returns:
    phi (np.array): hoekverdraaiing phi op elke centimeter lengte van het schip
    """
    phi = phi_acc + c
    #funcPlotFill(lengte_schip, phi, "Lengte van het schip L [m]", "φ(x) [deg]", "Relatieve hoek in graden over de lengte van het schip", "Hoekverdraaiing φ(x) [deg]", "y")
    return phi

#w
def doorbuiging(w_acc, lengte_schip, C):
    """
    Functie bepaalt de doorbuiging w op elke centimeter lengte van het schip
    Inputs:
    w_acc (np.array): w' op elke centimter lengte van het schip
    lengte_schip (np.array): array met de lengtewaardes van het schip per centimeter
    c (float): integratieconstante
    Returns:
    w (np.array): doorbuiging w op elke centimeter lengte van het schip
    """
    w = w_acc + C*(lengte_schip+9)
    w[0]=0
    w[-1]=0
    #funcPlotFill(lengte_schip, w, "Lengte van het schip L [m]", "Relatieve Doorbuiging w(x) [m]", "De relatieve doorbuiging over de lengte van het schip", "Doorbuiging w(x) [m]", "b")
    return w
# x_plot, y_plot, x_naam, y_naam, titel_naam, functie_naam

def parabolischProfielTP(zwaartepunt_tp, totaal_kracht, lengte_in_cm, STRAAL_TP):
    """de input van deze functie is het zwaartepunt van één Transition Piece, de totale kracht van alle transition pieces
    en een array over de lengte van het schip die te vinden is in de main. dan maakt hij eerst het bereik waar het parabolisch profiel van de TP's
    te vinden is. dan maakt hij van de fysieke positie een index in een array. in het 2de deel van de functie bereidt hij parabool waarden voor.
    x_norm zijn dan de genormaliseerde afstanden tov het zwaartepunt. in het laatste deel maakt hij het parabolisch profiel en alle negatieve waardes op 0.
    en dan zorgt hij ervoor dat de som gelijk is aan de totale kracht.
    DEZE FUNCTIE IS VERVANGEN DOOR calcParaboolFunctie
    """
    start = lengte_in_cm[0]
    eind = lengte_in_cm[-1]
    begin = max(zwaartepunt_tp - STRAAL_TP, start)
    eind = min(zwaartepunt_tp + STRAAL_TP, eind)
    idx_begin = int(begin - start)
    idx_eind = int(eind - start)

    bereik = np.arange(idx_begin, idx_eind + 1)
    afstanden = (bereik + start) - zwaartepunt_tp
    x_norm = afstanden / STRAAL_TP

    profiel = np.clip(1 - x_norm**2, 0, None)
    profiel /= profiel.sum()
    profiel *= totaal_kracht
    kracht = np.zeros(len(lengte_in_cm))
    for i in range(len(bereik)):
      kracht[int(bereik[0]*100)+i] = profiel[i]
    return kracht

# deze functie moeten nog geplot worden. met lengte op de x-as en krachtverdeling op de y-as. met als title: "Krachtverdeling over het Schip"


def calculateSpiegel(arr_lengte, dic, huiddikte):
  """
  functie bepaalt de verdeelde belasting van de huid. Er is gekozen voor een benadering gebaseerd op een gelijke verdeling die loopt van de achterste
  x-coördinaat tot een halve meter voor de spiegel
  Inputs:
  arr_lengte (np.array): array met de lengtewaardes van het schip per centimeter
  dic (dictionary): dictionary met de data uit het bestand hullareadata
  huiddikte (float): dikte van de huid in m
  Returns:
  arr_gewicht (np.array): array met de verdeelde belasting in N/m van de spiegel op elke centimeter van de lengte van het schip
  """
  fg_totaal = dic["Transom Area "][0]*huiddikte*WEIGHT_STAAL
  scaling = int(((len(arr_lengte)-1)/(arr_lengte[-1] - arr_lengte[0])))
  fg_per_cm = fg_totaal/(scaling/10)
  arr_gewicht = np.zeros(len(arr_lengte))
  for i in range(int(scaling)):
    arr_gewicht[i] += fg_per_cm
  return -arr_gewicht*(scaling/10)

def calculateHuid(arr_x, huiddikte, dic_shell):
  """
  functie berekent de verdeelde belasting van de huid.
  Inputs:
  arr_x: array met de lengtewaardes van het schip per centimeter (np.array)
  huiddikte: in m (float)
  dic_csa: dictionary met de waarden uit het shell_csa bestand (dictionary)
  Returns:
  arr_gewicht: een array met de waarden van de verdeelde belasting in N/m op elke centimeter van de lengte  (np.array)
  """
  x = dic_shell["X [m]"]
  w = np.zeros(len(arr_x))
  w = dic_shell["CROSS SECTION AREA OF SHELL PLATING [m2]"]*WEIGHT_STAAL*huiddikte
  f = ip.interp1d(x,w, kind='cubic')
  arr_gewicht = f(arr_x)
  return -arr_gewicht

def calculateTrapezium(arr_lengte, dic_bh, huiddikte):
  """
  functie bepaalt de verdeelde belasting van de tankschotten d.m.v. een benadering met trapezia.
  Inputs:
  arr_lengte (np.array): array met de lengtewaardes van het schip per centimeter
  dic_bh (dictionary): de dictionary met de waarden uit het BHData bestand
  huiddikte (float): dikte van de huid in m
  Returns:
  arr_gewicht (np.array): array met de verdeelde belasting van de tankschotten op elke centimeter lengte
  """
  arr_gewicht = np.zeros(len(arr_lengte))
  for x in dic_bh:
    xmin = dic_bh[x][4]
    xmax = dic_bh[x][5]
    lcg = dic_bh[x][1]
    A = dic_bh[x][0]*WEIGHT_STAAL*huiddikte
    ixb = int(round(xmin*100)-100*arr_lengte[0])
    ixe = int(round(xmax*100)-100*arr_lengte[0])
    lcg_l = lcg - xmin
    if lcg == xmin + (xmax-xmin)/2:
      a = A/(xmax-xmin)
      b = A/(xmax-xmin)
    elif lcg == xmin + (xmax-xmin)/3:
      a = A/(xmax-xmin)*2
      b = 0
    elif lcg == xmin + 2*(xmax-xmin)/3:
      a = 0
      b = A/(xmax-xmin)*2
    elif lcg < xmin + (xmax-xmin)/3 or lcg > xmin + 2*(xmax-xmin)/3:
      print(f"error: object moet opgedeeld worden")
      exit
    elif lcg < xmin + (xmax-xmin)/2:
      a = 4*A/(xmax-xmin) -  6*A*lcg_l/(xmax-xmin)**2
      b = 6*A*lcg_l/(xmax-xmin)**2-2*A/(xmax-xmin)
    else:
      a = 4*A/(xmax-xmin) -  6*A*lcg_l/(xmax-xmin)**2
      b = 6*A*lcg_l/(xmax-xmin)**2-2*A/(xmax-xmin)
    arr = np.linspace(a,b,ixe-ixb)
    for i in range(len(arr)):
      arr_gewicht[ixb+i] = arr_gewicht[ixb+i]+arr[i]
  return -arr_gewicht

def parabolischProfielKraan(zwaartepunt_tp, totaal_kracht, lengte_in_cm, straal_kraanhuis):
    """
    Nog te bepalen: straal kraanhuis als argument, lokale variabele bepaald binnen de functie of global variable.

    De functie bepaalt de verdeelde belasting van de kraan op het dek tijdens de hijsoperatie (dus inclusief een tussenstuk in de kraan)
    Imputs:
    zwaartepunt_tp (float): x-coördinaat van het aangrijpingspunt van het gewicht van het kraanhuis op het dek
    totaal_kracht (float): het totale gewicht van de kraan en kraanlast samen
    lengte_in_cm (np.array): een array van x-coördinaten voor elke centimeter van het schip. Deze array heeft dus 14901 elementen en loopt van -9 tot 140.
    Returns:
    kracht (np.array): een array met de verdeelde belasting op het dek ten gevolge van de kraan op elke centimeter van het schip. Deze array heeft dus 14901 elementen.
    """
    start = lengte_in_cm[0]
    eind_len = lengte_in_cm[-1]
    begin = max(zwaartepunt_tp - straal_kraanhuis, start)
    eind = min(zwaartepunt_tp + straal_kraanhuis, eind_len)
    #conversion to distance from stern instead of from achterloodlijn
    idx_begin = int((begin - start))
    idx_eind = int((eind - start))

    bereik = np.arange(idx_begin, idx_eind + 0.01, 0.01)
    afstanden = (bereik + start) - zwaartepunt_tp
    x_norm = afstanden / straal_kraanhuis
    profiel = np.clip(1 - x_norm**2, 0, None)
    profiel /= profiel.sum()
    profiel *= totaal_kracht
    kracht = np.zeros(len(lengte_in_cm))
    for i in range(len(bereik)):
      kracht[int(bereik[0]*100)+i] = profiel[i]
    return kracht

def berekenKrachtVerdeling(lading_posities, massas, lengte_in_cm, straal):
    """Deze functie bepaalt de verdeelde belasting van meerdere windmolentussenstukken
    Inputs:
    lading_posities (list): de x-coördinaten van de zwaartepunten van de windmolentussenstukken
    massas (list): de gewichten van de tussenstukken
    lengte_in_cm (np.array): array met de x-coördinaat met van elke centimeter lengte van het schip
    straal (float): straal van de windmolentussenstukken
    """
    krachtverdeling = np.zeros(len(lengte_in_cm))
    for pos in lading_posities:
        krachtverdeling += calcParaboolFunctie(pos, massas[0], lengte_in_cm, straal)
    return krachtverdeling

def calcParaboolFunctie(locatie, totaal_gewicht, arr_lengte, straal):
  """
  Functie stelt een paraboolvormige verdeelde belasting op voor een belasting dat een cirkelvormig contactoppervlak heeft met het dek en
  een homogene masseverdeling heeft.
  Inputs:
  locatie (float): de x-coördinaat van het zwaartepunt van de last in m
  totaal_gewicht (float): het gewicht van de last in N
  straal (float): straal van het contactoppervlak in m
  arr_lengte (np.array): array met de x-coördinaat met van elke centimeter lengte van het schip
  Returns:
  q_out (np.array): array met de verdeelde belasting van het object op elke centimeter lengte van het schip
  """
  n_points = 2 * straal * 100 + 1
  x = np.linspace(-straal, straal, n_points)

  #Hertzian pressure distribution: q(x) = q0 * sqrt(1 - (2x/L)^2)
  #Totale last = (π/4) * q0 * L → solve for q0
  q0 = (4 / np.pi) * totaal_gewicht / (2*straal)
  q = q0 * np.sqrt(1 - (2 * x / (2*straal))**2)

  #Kleine negatieve waarden corrigeren
  q = np.where(q <= 0, q, 0)

  #Op de juiste plaats in array zetten
  i_start = int((locatie - straal - arr_lengte[0])*100)
  q_out = np.zeros(len(arr_lengte))
  for i in range(len(q)):
    q_out[i_start+i] = q[i]
  return q_out